^D{"type":"result","subtype":"success","is_error":false,"duration_ms":283154,"duration_api_ms":287079,"num_turns":8,"result":"I need write permission to the project files. Could you grant write access so I can proceed? The system should be showing a permission prompt. Once granted, I'll continue with:\n\n1. Writing the upgraded `TaskEscrow.sol` (platform fees, bidding, subtasks)\n2. Setting up Hardhat with tests\n3. Building the CLI scripts\n4. Overhauling the entire Web UI\n\nPlease accept the write permission when prompted.","session_id":"acfb2ecd-c5b3-41c6-8160-07974f748c13","total_cost_usd":1.0098625500000002,"usage":{"input_tokens":10,"cache_creation_input_tokens":31356,"cache_read_input_tokens":380294,"output_tokens":16381,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":31356,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":3994,"outputTokens":9490,"cacheReadInputTokens":793378,"cacheCreationInputTokens":66707,"webSearchRequests":0,"costUSD":0.21416555,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":10,"outputTokens":16381,"cacheReadInputTokens":380294,"cacheCreationInputTokens":31356,"webSearchRequests":0,"costUSD":0.7956970000000001,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Write","tool_use_id":"toolu_01RC7B2LN7EMtijopoAZZMXK","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Agent Economy Protocol — USDC escrow with bidding, subtasks, and platform fees\n * @dev AI agents post tasks with USDC bounties. Other agents bid on work,\n *      deliver results, and get paid automatically. Supports agent-to-agent\n *      subcontracting via subtasks and dynamic pricing via competitive bidding.\n *\n *      Fee model: 2.5% platform fee on task approval, sent to feeRecipient.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // --- Constants ---\n    IERC20 public immutable usdc;\n    uint256 public constant FEE_BASIS_POINTS = 250; // 2.5%\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n    uint256 public constant MAX_BIDS_PER_TASK = 20;\n\n    // --- State ---\n    address public feeRecipient;\n    address public owner;\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalUsdcVolume;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;    // bytes32(0) if top-level task\n        uint256 bidCount;\n        bool useBidding;         // if true, must go through bid→accept flow\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;           // USDC amount the bidder wants to be paid\n        uint256 estimatedTime;   // estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;          // taskId => array of bids\n    mapping(bytes32 => bytes32[]) public subtasks;      // parentTaskId => child taskIds\n    mapping(address => uint256) public tasksCompletedBy; // agent => completed count\n    mapping(address => uint256) public totalEarnedBy;    // agent => total USDC earned\n\n    // Timeout: poster can refund if no claim/bid-accept after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool useBidding);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 amount);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n\n    // --- Modifiers ---\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // ==================== CORE TASK LIFECYCLE ====================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (6 decimals)\n     * @param useBidding If true, task uses bidding flow instead of direct claim\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool useBidding) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, useBidding);\n    }\n\n    /**\n     * @notice Backward-compatible createTask without bidding flag (defaults to no bidding)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: false\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ==================== BIDDING SYSTEM ====================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price USDC amount the bidder wants (can be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price exceeds bounty\");\n        require(task.bidCount < MAX_BIDS_PER_TASK, \"Max bids reached\");\n\n        // Prevent duplicate bids from same bidder\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid — assigns the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If the accepted price is less than bounty, refund the difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    // ==================== DIRECT CLAIM (non-bidding tasks) ====================\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.useBidding, \"Use bidding to claim this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ==================== DELIVERY & APPROVAL ====================\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable — releases USDC to worker minus platform fee\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 fee = (task.bounty * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer payout to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Update stats\n        totalTasksCompleted++;\n        tasksCompletedBy[task.worker]++;\n        totalEarnedBy[task.worker] += payout;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    // ==================== DISPUTES & REFUNDS ====================\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (after timeout or dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // ==================== SUBTASKS (Agent-to-Agent) ====================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent subcontracting)\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     * @param useBidding Whether subtask uses bidding\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool useBidding\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task not active\"\n        );\n        // Only the worker of the parent task (or poster if unclaimed) can create subtasks\n        if (parent.status == Status.Claimed) {\n            require(msg.sender == parent.worker, \"Only parent worker can create subtasks\");\n        } else {\n            require(msg.sender == parent.poster, \"Only parent poster can create subtasks\");\n        }\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    // ==================== VIEW FUNCTIONS ====================\n\n    /**\n     * @notice Get task details\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get all bids for a task\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    /**\n     * @notice Get subtask IDs for a parent task\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get bid count for a task\n     */\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    /**\n     * @notice Get platform statistics\n     */\n    function getPlatformStats() external view returns (\n        uint256 _totalTasksCreated,\n        uint256 _totalTasksCompleted,\n        uint256 _totalUsdcVolume,\n        uint256 _totalFeesCollected\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalUsdcVolume, totalFeesCollected);\n    }\n\n    /**\n     * @notice Get agent statistics\n     */\n    function getAgentStats(address agent) external view returns (\n        uint256 completed,\n        uint256 earned\n    ) {\n        return (tasksCompletedBy[agent], totalEarnedBy[agent]);\n    }\n\n    // ==================== ADMIN ====================\n\n    /**\n     * @notice Update fee recipient address\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid address\");\n        address old = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(old, _newRecipient);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01SQgaopHHW7d6uRpYis6qNK","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Agent Economy Protocol — USDC escrow with bidding, subtasks, and platform fees\n * @dev AI agents post tasks with USDC bounties. Other agents bid on work,\n *      deliver results, and get paid automatically. Supports agent-to-agent\n *      subcontracting via subtasks and dynamic pricing via competitive bidding.\n *\n *      Fee model: 2.5% platform fee on task approval, sent to feeRecipient.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // --- Constants ---\n    IERC20 public immutable usdc;\n    uint256 public constant FEE_BASIS_POINTS = 250; // 2.5%\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n    uint256 public constant MAX_BIDS_PER_TASK = 20;\n\n    // --- State ---\n    address public feeRecipient;\n    address public owner;\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalUsdcVolume;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;    // bytes32(0) if top-level task\n        uint256 bidCount;\n        bool useBidding;         // if true, must go through bid→accept flow\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;           // USDC amount the bidder wants to be paid\n        uint256 estimatedTime;   // estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;          // taskId => array of bids\n    mapping(bytes32 => bytes32[]) public subtasks;      // parentTaskId => child taskIds\n    mapping(address => uint256) public tasksCompletedBy; // agent => completed count\n    mapping(address => uint256) public totalEarnedBy;    // agent => total USDC earned\n\n    // Timeout: poster can refund if no claim/bid-accept after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool useBidding);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 amount);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n\n    // --- Modifiers ---\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // ==================== CORE TASK LIFECYCLE ====================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (6 decimals)\n     * @param useBidding If true, task uses bidding flow instead of direct claim\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool useBidding) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, useBidding);\n    }\n\n    /**\n     * @notice Backward-compatible createTask without bidding flag (defaults to no bidding)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: false\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ==================== BIDDING SYSTEM ====================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price USDC amount the bidder wants (can be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price exceeds bounty\");\n        require(task.bidCount < MAX_BIDS_PER_TASK, \"Max bids reached\");\n\n        // Prevent duplicate bids from same bidder\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid — assigns the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If the accepted price is less than bounty, refund the difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    // ==================== DIRECT CLAIM (non-bidding tasks) ====================\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.useBidding, \"Use bidding to claim this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ==================== DELIVERY & APPROVAL ====================\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable — releases USDC to worker minus platform fee\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 fee = (task.bounty * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer payout to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Update stats\n        totalTasksCompleted++;\n        tasksCompletedBy[task.worker]++;\n        totalEarnedBy[task.worker] += payout;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    // ==================== DISPUTES & REFUNDS ====================\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (after timeout or dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // ==================== SUBTASKS (Agent-to-Agent) ====================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent subcontracting)\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     * @param useBidding Whether subtask uses bidding\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool useBidding\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task not active\"\n        );\n        // Only the worker of the parent task (or poster if unclaimed) can create subtasks\n        if (parent.status == Status.Claimed) {\n            require(msg.sender == parent.worker, \"Only parent worker can create subtasks\");\n        } else {\n            require(msg.sender == parent.poster, \"Only parent poster can create subtasks\");\n        }\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    // ==================== VIEW FUNCTIONS ====================\n\n    /**\n     * @notice Get task details\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get all bids for a task\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    /**\n     * @notice Get subtask IDs for a parent task\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get bid count for a task\n     */\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    /**\n     * @notice Get platform statistics\n     */\n    function getPlatformStats() external view returns (\n        uint256 _totalTasksCreated,\n        uint256 _totalTasksCompleted,\n        uint256 _totalUsdcVolume,\n        uint256 _totalFeesCollected\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalUsdcVolume, totalFeesCollected);\n    }\n\n    /**\n     * @notice Get agent statistics\n     */\n    function getAgentStats(address agent) external view returns (\n        uint256 completed,\n        uint256 earned\n    ) {\n        return (tasksCompletedBy[agent], totalEarnedBy[agent]);\n    }\n\n    // ==================== ADMIN ====================\n\n    /**\n     * @notice Update fee recipient address\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid address\");\n        address old = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(old, _newRecipient);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01L8nByYFByA8ujbeXk9rksy","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Agent Economy Protocol — USDC escrow with bidding, subtasks, and platform fees\n * @dev AI agents post tasks with USDC bounties. Other agents bid on work,\n *      deliver results, and get paid automatically. Supports agent-to-agent\n *      subcontracting via subtasks and dynamic pricing via competitive bidding.\n *\n *      Fee model: 2.5% platform fee on task approval, sent to feeRecipient.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // --- Constants ---\n    IERC20 public immutable usdc;\n    uint256 public constant FEE_BASIS_POINTS = 250; // 2.5%\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n    uint256 public constant MAX_BIDS_PER_TASK = 20;\n\n    // --- State ---\n    address public feeRecipient;\n    address public owner;\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalUsdcVolume;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;    // bytes32(0) if top-level task\n        uint256 bidCount;\n        bool useBidding;         // if true, must go through bid→accept flow\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;           // USDC amount the bidder wants to be paid\n        uint256 estimatedTime;   // estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;          // taskId => array of bids\n    mapping(bytes32 => bytes32[]) public subtasks;      // parentTaskId => child taskIds\n    mapping(address => uint256) public tasksCompletedBy; // agent => completed count\n    mapping(address => uint256) public totalEarnedBy;    // agent => total USDC earned\n\n    // Timeout: poster can refund if no claim/bid-accept after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool useBidding);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 amount);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n\n    // --- Modifiers ---\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // ==================== CORE TASK LIFECYCLE ====================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (6 decimals)\n     * @param useBidding If true, task uses bidding flow instead of direct claim\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool useBidding) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, useBidding);\n    }\n\n    /**\n     * @notice Backward-compatible createTask without bidding flag (defaults to no bidding)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            useBidding: false\n        });\n\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ==================== BIDDING SYSTEM ====================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price USDC amount the bidder wants (can be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price exceeds bounty\");\n        require(task.bidCount < MAX_BIDS_PER_TASK, \"Max bids reached\");\n\n        // Prevent duplicate bids from same bidder\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid — assigns the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.useBidding, \"Task does not use bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If the accepted price is less than bounty, refund the difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    // ==================== DIRECT CLAIM (non-bidding tasks) ====================\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.useBidding, \"Use bidding to claim this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ==================== DELIVERY & APPROVAL ====================\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable — releases USDC to worker minus platform fee\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 fee = (task.bounty * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer payout to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Update stats\n        totalTasksCompleted++;\n        tasksCompletedBy[task.worker]++;\n        totalEarnedBy[task.worker] += payout;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    // ==================== DISPUTES & REFUNDS ====================\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (after timeout or dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // ==================== SUBTASKS (Agent-to-Agent) ====================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent subcontracting)\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     * @param useBidding Whether subtask uses bidding\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool useBidding\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task not active\"\n        );\n        if (parent.status == Status.Claimed) {\n            require(msg.sender == parent.worker, \"Only parent worker can create subtasks\");\n        } else {\n            require(msg.sender == parent.poster, \"Only parent poster can create subtasks\");\n        }\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            useBidding: useBidding\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n        totalUsdcVolume += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    // ==================== VIEW FUNCTIONS ====================\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasksCreated,\n        uint256 _totalTasksCompleted,\n        uint256 _totalUsdcVolume,\n        uint256 _totalFeesCollected\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalUsdcVolume, totalFeesCollected);\n    }\n\n    function getAgentStats(address agent) external view returns (\n        uint256 completed,\n        uint256 earned\n    ) {\n        return (tasksCompletedBy[agent], totalEarnedBy[agent]);\n    }\n\n    // ==================== ADMIN ====================\n\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid address\");\n        address old = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(old, _newRecipient);\n    }\n}\n"}}],"uuid":"853ef637-be6e-4bef-a08f-9865f679a358"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h