^D{"type":"result","subtype":"success","is_error":false,"duration_ms":467724,"duration_api_ms":478514,"num_turns":13,"result":"I see that the user needs to grant write permissions. Let me wait for that and provide a summary of the changes I'm making.\n\nThe upgraded smart contract includes:\n\n**New Features:**\n1. **Platform Fee (2.5%)** - Collected on every `approveTask()` call\n2. **Bidding System** - `bidOnTask()`, `acceptBid()`, `getTaskBids()`\n3. **Subtask Support** - `createSubtask()`, `getSubtasks()`  \n4. **Cancel Task** - `cancelTask()` for unclaimed tasks\n\n**Key Changes:**\n- Added `Ownable` for admin functions\n- New `Status.Bidding` and `Status.Cancelled` states\n- Extended `Task` struct with `acceptedPrice`, `parentTaskId`, `hasBids`, `bidCount`\n- New `Bid` struct\n- Fee recipient configurable via `setFeeRecipient()`\n- Backward compatible `createTask(bytes32, uint256)` overload\n\nOnce you grant write permissions, I'll be able to save the contract and continue setting up Hardhat with tests.","session_id":"ea7bfe5c-b85e-4e9b-a00e-41e34975547b","total_cost_usd":1.65500605,"usage":{"input_tokens":13,"cache_creation_input_tokens":52891,"cache_read_input_tokens":610004,"output_tokens":34389,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":52891,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":13,"outputTokens":34389,"cacheReadInputTokens":610004,"cacheCreationInputTokens":52891,"webSearchRequests":0,"costUSD":1.49536075,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":14182,"outputTokens":10085,"cacheReadInputTokens":402608,"cacheCreationInputTokens":43822,"webSearchRequests":0,"costUSD":0.1596453,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Write","tool_use_id":"toolu_017zrr3Wew9Dp5vL4nUQ63GW","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01PxvL86PrvoVQhFSB8yuTKV","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01MRwM3N2ysEVEhrj3NtrZaU","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01BXqTxQoupyLbNTxEd2mX7m","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}\n"}},{"tool_name":"Edit","tool_use_id":"toolu_01VYFV1cfCojGSQn1T2rfGKu","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","old_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers claim and deliver, \n *      poster approves to release funds. Supports disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 bounty);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n\n    constructor(address _usdc) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Release USDC to worker\n        usdc.safeTransfer(task.worker, task.bounty);\n\n        emit TaskApproved(taskId, task.worker, task.bounty);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        // In disputed state, funds remain in escrow\n        // A more advanced version would involve an arbitrator\n        // For now, disputed funds can be refunded by poster\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n        \n        bool canRefund = false;\n        \n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n        \n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        // Refund if submitted and dispute window expired without approval\n        // (Auto-approve protection: if poster never approves, worker can't get funds,\n        //  but poster can only refund during dispute. After dispute window,\n        //  the task auto-approves — handled off-chain or by worker calling approveTask)\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n}","new_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}","replace_all":false}},{"tool_name":"Write","tool_use_id":"toolu_01KCiL93rzZ3DBPqh8Umfzc8","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Features: escrow, bidding system, subtasks, platform fees, disputes\n *\n * Agent Supply Chain Flow:\n * 1. Poster creates task with USDC bounty (deposited in escrow)\n * 2. Agents bid on the task (price + estimated time)\n * 3. Poster accepts best bid\n * 4. Worker delivers, poster approves\n * 5. USDC released: 97.5% to worker, 2.5% platform fee\n *\n * Subtasks: Workers can create subtasks to subcontract work to other agents\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant FEE_BASIS_POINTS = 250;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Bidding, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;           // Original bounty amount\n        uint256 acceptedPrice;    // Final accepted bid price (may differ from bounty)\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: reference to parent\n        bool hasBids;             // True if task accepts bids\n        uint256 bidCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // ============ Events ============\n\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptsBids\n    );\n\n    event TaskBid(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n\n    event BidAccepted(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price\n    );\n\n    event TaskClaimed(\n        bytes32 indexed taskId,\n        address indexed worker\n    );\n\n    event DeliverableSubmitted(\n        bytes32 indexed taskId,\n        bytes32 deliverableHash\n    );\n\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 feeAmount\n    );\n\n    event TaskDisputed(bytes32 indexed taskId);\n\n    event TaskRefunded(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 amount\n    );\n\n    event TaskCancelled(\n        bytes32 indexed taskId,\n        address indexed poster\n    );\n\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient\n    );\n\n    event FeeCollected(\n        bytes32 indexed taskId,\n        uint256 amount,\n        address indexed recipient\n    );\n\n    // ============ Constructor ============\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the fee recipient address\n     * @param _newRecipient New address to receive platform fees\n     */\n    function setFeeRecipient(address _newRecipient) external onlyOwner {\n        require(_newRecipient != address(0), \"Invalid fee recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = _newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, _newRecipient);\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptsBids If true, task enters Bidding status; if false, direct claim\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount, // Default to bounty if no bids\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Create a task with default settings (no bids, direct claim)\n     * @dev Backward compatible with original interface\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            hasBids: false,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid exceeds bounty\");\n\n        // Check if bidder already has a bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already placed a bid\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a specific bid\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Bidding, \"Task not in bidding\");\n        require(msg.sender == task.poster, \"Only poster can accept\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.acceptedPrice = acceptedPrice;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // Refund excess if bid was lower than bounty\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    // ============ Subtask System ============\n\n    /**\n     * @notice Create a subtask linked to a parent task\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId Parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for subtask\n     * @param acceptsBids Whether subtask accepts bids\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptsBids\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Submitted,\n            \"Parent task not active\"\n        );\n        require(msg.sender == parentTask.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Worker funds the subtask from their own funds\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender, // The worker becomes the poster of subtask\n            worker: address(0),\n            bounty: bountyAmount,\n            acceptedPrice: bountyAmount,\n            status: acceptsBids ? Status.Bidding : Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            hasBids: acceptsBids,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptsBids);\n    }\n\n    /**\n     * @notice Get all subtasks for a parent task\n     * @param parentTaskId Parent task ID\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ Task Claiming (Direct) ============\n\n    /**\n     * @notice Claim an open task as a worker (for tasks without bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open for direct claim\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    // ============ Work Submission & Approval ============\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee (2.5%)\n        uint256 payoutAmount = task.acceptedPrice;\n        uint256 feeAmount = (payoutAmount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n        uint256 workerAmount = payoutAmount - feeAmount;\n\n        // Transfer to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        // Transfer fee to platform\n        if (feeAmount > 0) {\n            usdc.safeTransfer(feeRecipient, feeAmount);\n            totalFeesCollected += feeAmount;\n            emit FeeCollected(taskId, feeAmount, feeRecipient);\n        }\n\n        emit TaskApproved(taskId, task.worker, workerAmount, feeAmount);\n    }\n\n    // ============ Disputes & Refunds ============\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n        uint256 refundAmount = task.acceptedPrice;\n\n        // Refund if open/bidding and claim timeout expired\n        if (\n            (task.status == Status.Open || task.status == Status.Bidding) &&\n            block.timestamp > task.createdAt + claimTimeout\n        ) {\n            canRefund = true;\n            refundAmount = task.bounty; // Full bounty refund if never claimed\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, refundAmount);\n\n        emit TaskRefunded(taskId, task.poster, refundAmount);\n    }\n\n    /**\n     * @notice Cancel a task that hasn't been claimed yet\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(\n            task.status == Status.Open || task.status == Status.Bidding,\n            \"Can only cancel unclaimed tasks\"\n        );\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate fee amount for a given bounty\n     * @param amount Amount to calculate fee for\n     * @return Fee amount\n     */\n    function calculateFee(uint256 amount) external pure returns (uint256) {\n        return (amount * FEE_BASIS_POINTS) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return Total fees collected\n     */\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n}\n"}}],"uuid":"c1002dc0-255f-4a48-99cf-f5544afdbd99"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h