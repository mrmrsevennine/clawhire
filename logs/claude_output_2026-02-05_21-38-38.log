^D{"type":"result","subtype":"success","is_error":false,"duration_ms":262714,"duration_api_ms":265109,"num_turns":10,"result":"I need permission to write files to proceed with the hackathon project. Could you grant write permission so I can update the smart contract, set up Hardhat, create tests, and build the web UI?","session_id":"fab7cb87-df8d-477c-995d-5fcb1eafb8f9","total_cost_usd":0.98283115,"usage":{"input_tokens":10,"cache_creation_input_tokens":32234,"cache_read_input_tokens":376125,"output_tokens":16729,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":32234,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":10,"outputTokens":16729,"cacheReadInputTokens":376125,"cacheCreationInputTokens":32234,"webSearchRequests":0,"costUSD":0.8078000000000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":7114,"outputTokens":7411,"cacheReadInputTokens":656509,"cacheCreationInputTokens":52169,"webSearchRequests":0,"costUSD":0.17503115,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Write","tool_use_id":"toolu_01KAhUAZqEHijgrwKe7QRMAE","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Supports: task creation, bidding, subtasks, platform fees, disputes, and refunds.\n *      Agents post tasks with USDC bounties, other agents bid, poster accepts bid,\n *      worker delivers, poster approves, and USDC flows automatically.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration (basis points: 250 = 2.5%)\n    uint256 public platformFeeBps = 250;\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;          // Amount bidder will accept (can be <= bounty)\n        uint256 estimatedTime;  // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        // New fields for bidding\n        bool biddingEnabled;\n        uint256 bidCount;\n        // Subtask support\n        bytes32 parentTaskId;\n        uint256 subtaskCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids;  // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => bool)) public hasBid;   // taskId => bidder => hasBid\n    mapping(bytes32 => bytes32[]) public subtasks;                // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool biddingEnabled);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n\n    // Subtask events\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n\n    // Platform events\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event FeesWithdrawn(address indexed recipient, uint256 amount);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param biddingEnabled If true, agents must bid; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool biddingEnabled) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Legacy createTask for backward compatibility (bidding disabled by default)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: false,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Amount the bidder will accept (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.biddingEnabled, \"Bidding not enabled for this task\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(!hasBid[taskId][msg.sender], \"Already placed a bid\");\n\n        uint256 bidIndex = task.bidCount;\n        taskBids[taskId][bidIndex] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        hasBid[taskId][msg.sender] = true;\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime, bidIndex);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to assign\n     * @param bidIndex Index of the bid to accept\n     */\n    function acceptBid(bytes32 taskId, uint256 bidIndex) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bid\");\n        require(bidIndex < task.bidCount, \"Invalid bid index\");\n\n        Bid storage bid = taskBids[taskId][bidIndex];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bid.bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price < bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;  // Update bounty to accepted price\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bid.bidder, bid.price);\n        emit TaskClaimed(taskId, bid.bidder);\n    }\n\n    /**\n     * @notice Get bid details\n     * @param taskId Task ID\n     * @param bidIndex Bid index\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task ID\n     */\n    function getAllBids(bytes32 taskId) external view returns (Bid[] memory) {\n        Task storage task = tasks[taskId];\n        Bid[] memory bids = new Bid[](task.bidCount);\n        for (uint256 i = 0; i < task.bidCount; i++) {\n            bids[i] = taskBids[taskId][i];\n        }\n        return bids;\n    }\n\n    // ============ SUBTASK SYSTEM ============\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param subtaskId Unique subtask identifier\n     * @param parentTaskId Parent task this subtask belongs to\n     * @param bountyAmount USDC bounty for the subtask\n     * @param biddingEnabled Whether bidding is enabled for the subtask\n     */\n    function createSubtask(\n        bytes32 subtaskId,\n        bytes32 parentTaskId,\n        uint256 bountyAmount,\n        bool biddingEnabled\n    ) external nonReentrant {\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parentTask.worker || msg.sender == parentTask.poster,\n            \"Only parent task worker or poster can create subtask\"\n        );\n        require(\n            parentTask.status == Status.Open || parentTask.status == Status.Claimed,\n            \"Parent task must be open or claimed\"\n        );\n\n        // Transfer USDC from subtask creator to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: parentTaskId,\n            subtaskCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        parentTask.subtaskCount++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.biddingEnabled, \"Must bid on this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task and refund (only if no bids or claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.bidCount == 0, \"Cannot cancel task with bids\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Check if a task exists\n     * @param taskId Task to check\n     */\n    function taskExists(bytes32 taskId) external view returns (bool) {\n        return tasks[taskId].poster != address(0);\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee too high (max 10%)\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient (only owner)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (only owner)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (only owner)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 hours, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01GN12FS8E2VmtyMbgpvaGPa","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Supports: task creation, bidding, subtasks, platform fees, disputes, and refunds.\n *      Agents post tasks with USDC bounties, other agents bid, poster accepts bid,\n *      worker delivers, poster approves, and USDC flows automatically.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration (basis points: 250 = 2.5%)\n    uint256 public platformFeeBps = 250;\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;          // Amount bidder will accept (can be <= bounty)\n        uint256 estimatedTime;  // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        // New fields for bidding\n        bool biddingEnabled;\n        uint256 bidCount;\n        // Subtask support\n        bytes32 parentTaskId;\n        uint256 subtaskCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids;  // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => bool)) public hasBid;   // taskId => bidder => hasBid\n    mapping(bytes32 => bytes32[]) public subtasks;                // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool biddingEnabled);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n\n    // Subtask events\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n\n    // Platform events\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event FeesWithdrawn(address indexed recipient, uint256 amount);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param biddingEnabled If true, agents must bid; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool biddingEnabled) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Legacy createTask for backward compatibility (bidding disabled by default)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: false,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Amount the bidder will accept (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.biddingEnabled, \"Bidding not enabled for this task\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(!hasBid[taskId][msg.sender], \"Already placed a bid\");\n\n        uint256 bidIndex = task.bidCount;\n        taskBids[taskId][bidIndex] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        hasBid[taskId][msg.sender] = true;\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime, bidIndex);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to assign\n     * @param bidIndex Index of the bid to accept\n     */\n    function acceptBid(bytes32 taskId, uint256 bidIndex) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bid\");\n        require(bidIndex < task.bidCount, \"Invalid bid index\");\n\n        Bid storage bid = taskBids[taskId][bidIndex];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bid.bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price < bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;  // Update bounty to accepted price\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bid.bidder, bid.price);\n        emit TaskClaimed(taskId, bid.bidder);\n    }\n\n    /**\n     * @notice Get bid details\n     * @param taskId Task ID\n     * @param bidIndex Bid index\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task ID\n     */\n    function getAllBids(bytes32 taskId) external view returns (Bid[] memory) {\n        Task storage task = tasks[taskId];\n        Bid[] memory bids = new Bid[](task.bidCount);\n        for (uint256 i = 0; i < task.bidCount; i++) {\n            bids[i] = taskBids[taskId][i];\n        }\n        return bids;\n    }\n\n    // ============ SUBTASK SYSTEM ============\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param subtaskId Unique subtask identifier\n     * @param parentTaskId Parent task this subtask belongs to\n     * @param bountyAmount USDC bounty for the subtask\n     * @param biddingEnabled Whether bidding is enabled for the subtask\n     */\n    function createSubtask(\n        bytes32 subtaskId,\n        bytes32 parentTaskId,\n        uint256 bountyAmount,\n        bool biddingEnabled\n    ) external nonReentrant {\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parentTask.worker || msg.sender == parentTask.poster,\n            \"Only parent task worker or poster can create subtask\"\n        );\n        require(\n            parentTask.status == Status.Open || parentTask.status == Status.Claimed,\n            \"Parent task must be open or claimed\"\n        );\n\n        // Transfer USDC from subtask creator to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: parentTaskId,\n            subtaskCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        parentTask.subtaskCount++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.biddingEnabled, \"Must bid on this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task and refund (only if no bids or claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.bidCount == 0, \"Cannot cancel task with bids\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Check if a task exists\n     * @param taskId Task to check\n     */\n    function taskExists(bytes32 taskId) external view returns (bool) {\n        return tasks[taskId].poster != address(0);\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee too high (max 10%)\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient (only owner)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (only owner)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (only owner)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 hours, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01DBxAGD6YJv6jkWkPhbfBhp","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Supports: task creation, bidding, subtasks, platform fees, disputes, and refunds.\n *      Agents post tasks with USDC bounties, other agents bid, poster accepts bid,\n *      worker delivers, poster approves, and USDC flows automatically.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration (basis points: 250 = 2.5%)\n    uint256 public platformFeeBps = 250;\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Bid {\n        address bidder;\n        uint256 price;          // Amount bidder will accept (can be <= bounty)\n        uint256 estimatedTime;  // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        // New fields for bidding\n        bool biddingEnabled;\n        uint256 bidCount;\n        // Subtask support\n        bytes32 parentTaskId;\n        uint256 subtaskCount;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids;  // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => bool)) public hasBid;   // taskId => bidder => hasBid\n    mapping(bytes32 => bytes32[]) public subtasks;                // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool biddingEnabled);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n\n    // Subtask events\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n\n    // Platform events\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event FeesWithdrawn(address indexed recipient, uint256 amount);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param biddingEnabled If true, agents must bid; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool biddingEnabled) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Legacy createTask for backward compatibility (bidding disabled by default)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: false,\n            bidCount: 0,\n            parentTaskId: bytes32(0),\n            subtaskCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, false);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Amount the bidder will accept (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.biddingEnabled, \"Bidding not enabled for this task\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(!hasBid[taskId][msg.sender], \"Already placed a bid\");\n\n        uint256 bidIndex = task.bidCount;\n        taskBids[taskId][bidIndex] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        hasBid[taskId][msg.sender] = true;\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime, bidIndex);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to assign\n     * @param bidIndex Index of the bid to accept\n     */\n    function acceptBid(bytes32 taskId, uint256 bidIndex) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bid\");\n        require(bidIndex < task.bidCount, \"Invalid bid index\");\n\n        Bid storage bid = taskBids[taskId][bidIndex];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bid.bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price < bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;  // Update bounty to accepted price\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bid.bidder, bid.price);\n        emit TaskClaimed(taskId, bid.bidder);\n    }\n\n    /**\n     * @notice Get bid details\n     * @param taskId Task ID\n     * @param bidIndex Bid index\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task ID\n     */\n    function getAllBids(bytes32 taskId) external view returns (Bid[] memory) {\n        Task storage task = tasks[taskId];\n        Bid[] memory bids = new Bid[](task.bidCount);\n        for (uint256 i = 0; i < task.bidCount; i++) {\n            bids[i] = taskBids[taskId][i];\n        }\n        return bids;\n    }\n\n    // ============ SUBTASK SYSTEM ============\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param subtaskId Unique subtask identifier\n     * @param parentTaskId Parent task this subtask belongs to\n     * @param bountyAmount USDC bounty for the subtask\n     * @param biddingEnabled Whether bidding is enabled for the subtask\n     */\n    function createSubtask(\n        bytes32 subtaskId,\n        bytes32 parentTaskId,\n        uint256 bountyAmount,\n        bool biddingEnabled\n    ) external nonReentrant {\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parentTask.worker || msg.sender == parentTask.poster,\n            \"Only parent task worker or poster can create subtask\"\n        );\n        require(\n            parentTask.status == Status.Open || parentTask.status == Status.Claimed,\n            \"Parent task must be open or claimed\"\n        );\n\n        // Transfer USDC from subtask creator to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            biddingEnabled: biddingEnabled,\n            bidCount: 0,\n            parentTaskId: parentTaskId,\n            subtaskCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        parentTask.subtaskCount++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, biddingEnabled);\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (only for non-bidding tasks)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.biddingEnabled, \"Must bid on this task\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task and refund (only if no bids or claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.bidCount == 0, \"Cannot cancel task with bids\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Check if a task exists\n     * @param taskId Task to check\n     */\n    function taskExists(bytes32 taskId) external view returns (bool) {\n        return tasks[taskId].poster != address(0);\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee too high (max 10%)\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient (only owner)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (only owner)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (only owner)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 hours, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}}],"uuid":"ab04403c-99bc-4e37-9010-4adbbe98339e"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h