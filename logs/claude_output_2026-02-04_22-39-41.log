^D{"type":"result","subtype":"success","is_error":false,"duration_ms":334323,"duration_api_ms":339122,"num_turns":10,"result":"It seems I need you to grant write permissions to the project directory. The tool is awaiting your approval to write files to `/Users/timmethy/Developer/claw-marketplace/`. Could you approve the write permission so I can proceed with the implementation?\n\nIn the meantime, let me outline what I've prepared for the upgraded TaskEscrow.sol:\n\n**New features added:**\n1. **Platform Fee (2.5%)** — On `approveTask()`, 250 bps is sent to `feeRecipient`, remainder to worker\n2. **Bidding System** — `bidOnTask(taskId, price, estimatedTime)` + `acceptBid(taskId, bidder)`\n3. **Subtask Support** — `createSubtask(parentTaskId, subtaskId, bountyAmount)` for agent supply chains\n4. **Platform Stats** — `totalFeesCollected`, `totalTasksCreated`, `totalTasksCompleted`, `totalVolumeUsdc`\n5. **Admin Controls** — `setFeeRecipient()`, `transferOwnership()`\n6. **View Functions** — `getBid()`, `getTaskBidders()`, `getSubtasks()`, `getPlatformStats()`, `calculateFee()`\n7. **New Events** — `TaskBid`, `BidAccepted`, `SubtaskCreated`, `FeeRecipientUpdated`, `OwnershipTransferred`\n\nThe constructor now takes `(address _usdc, address _feeRecipient)` — fee recipient is configurable, not hardcoded.\n\nPlease approve the write permission and I'll continue with setting up Hardhat, tests, CLI scripts, and the web UI.","session_id":"3d4bf19f-bdf3-4bb5-b605-8db1ca9d9d8f","total_cost_usd":1.2459573500000003,"usage":{"input_tokens":12,"cache_creation_input_tokens":39897,"cache_read_input_tokens":522259,"output_tokens":22757,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":39897,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":8446,"outputTokens":10714,"cacheReadInputTokens":496281,"cacheCreationInputTokens":43874,"webSearchRequests":0,"costUSD":0.16648659999999998,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":12,"outputTokens":22757,"cacheReadInputTokens":522259,"cacheCreationInputTokens":39897,"webSearchRequests":0,"costUSD":1.07947075,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Bash","tool_use_id":"toolu_013MNLX47N1hseT9DTQKYJYF","tool_input":{"command":"tree -L 3 /Users/timmethy/Developer/claw-marketplace/skill -I \"node_modules\"","description":"Show tree structure of skill directory excluding node_modules"}},{"tool_name":"Write","tool_use_id":"toolu_017BgaBtgY3aJteS7K5ZAaTy","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid on tasks,\n *      poster accepts bids, worker delivers, poster approves to release funds.\n *      Supports bidding, subtasks (agent supply chains), platform fees,\n *      disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant PLATFORM_FEE_BPS = 250;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    address public owner;\n\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalVolumeUsdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if no parent\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    // taskId => bidder address => Bid\n    mapping(bytes32 => mapping(address => Bid)) public bids;\n    // taskId => array of bidder addresses\n    mapping(bytes32 => address[]) public taskBidders;\n    // taskId => array of subtask IDs\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Timeout: poster can refund if no claim/bid accepted after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // --- Admin ---\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        address old = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(old, _feeRecipient);\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Invalid owner\");\n        address old = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(old, _newOwner);\n    }\n\n    // --- Core Functions ---\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Bid on an open task with a proposed price and estimated time\n     * @param taskId Task to bid on\n     * @param price Proposed USDC price (can differ from bounty for negotiation)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price cannot exceed bounty\");\n        require(bids[taskId][msg.sender].bidder == address(0), \"Already bid\");\n\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        taskBidders[taskId].push(msg.sender);\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task, assigning the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent supply chains)\n     * @dev The caller must be the worker of the parent task and funds come from their own balance\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(bytes32 parentTaskId, bytes32 subtaskId, uint256 bountyAmount) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Submitted,\n            \"Parent must be claimed or submitted\"\n        );\n        require(msg.sender == parent.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remainder to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        totalTasksCompleted++;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // --- View Functions ---\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    function getTaskBidders(bytes32 taskId) external view returns (address[] memory) {\n        return taskBidders[taskId];\n    }\n\n    function getSubtasks(bytes32 taskId) external view returns (bytes32[] memory) {\n        return subtasks[taskId];\n    }\n\n    function getSubtaskCount(bytes32 taskId) external view returns (uint256) {\n        return subtasks[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasks,\n        uint256 _totalCompleted,\n        uint256 _totalVolume,\n        uint256 _totalFees\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalVolumeUsdc, totalFeesCollected);\n    }\n\n    /**\n     * @notice Calculate fee for a given bounty amount\n     * @param bountyAmount The bounty to calculate fee for\n     */\n    function calculateFee(uint256 bountyAmount) external pure returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_016Geah9cdsG3bYnwVPLhLdg","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid on tasks,\n *      poster accepts bids, worker delivers, poster approves to release funds.\n *      Supports bidding, subtasks (agent supply chains), platform fees,\n *      disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant PLATFORM_FEE_BPS = 250;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    address public owner;\n\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalVolumeUsdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if no parent\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    // taskId => bidder address => Bid\n    mapping(bytes32 => mapping(address => Bid)) public bids;\n    // taskId => array of bidder addresses\n    mapping(bytes32 => address[]) public taskBidders;\n    // taskId => array of subtask IDs\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Timeout: poster can refund if no claim/bid accepted after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // --- Admin ---\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        address old = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(old, _feeRecipient);\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Invalid owner\");\n        address old = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(old, _newOwner);\n    }\n\n    // --- Core Functions ---\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Bid on an open task with a proposed price and estimated time\n     * @param taskId Task to bid on\n     * @param price Proposed USDC price (can differ from bounty for negotiation)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price cannot exceed bounty\");\n        require(bids[taskId][msg.sender].bidder == address(0), \"Already bid\");\n\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        taskBidders[taskId].push(msg.sender);\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task, assigning the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent supply chains)\n     * @dev The caller must be the worker of the parent task and funds come from their own balance\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(bytes32 parentTaskId, bytes32 subtaskId, uint256 bountyAmount) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Submitted,\n            \"Parent must be claimed or submitted\"\n        );\n        require(msg.sender == parent.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remainder to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        totalTasksCompleted++;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // --- View Functions ---\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    function getTaskBidders(bytes32 taskId) external view returns (address[] memory) {\n        return taskBidders[taskId];\n    }\n\n    function getSubtasks(bytes32 taskId) external view returns (bytes32[] memory) {\n        return subtasks[taskId];\n    }\n\n    function getSubtaskCount(bytes32 taskId) external view returns (uint256) {\n        return subtasks[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasks,\n        uint256 _totalCompleted,\n        uint256 _totalVolume,\n        uint256 _totalFees\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalVolumeUsdc, totalFeesCollected);\n    }\n\n    /**\n     * @notice Calculate fee for a given bounty amount\n     * @param bountyAmount The bounty to calculate fee for\n     */\n    function calculateFee(uint256 bountyAmount) external pure returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_017cSyzXgo84zZdMhezYuRWT","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid on tasks,\n *      poster accepts bids, worker delivers, poster approves to release funds.\n *      Supports bidding, subtasks (agent supply chains), platform fees,\n *      disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant PLATFORM_FEE_BPS = 250;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    address public owner;\n\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalVolumeUsdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if no parent\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    // taskId => bidder address => Bid\n    mapping(bytes32 => mapping(address => Bid)) public bids;\n    // taskId => array of bidder addresses\n    mapping(bytes32 => address[]) public taskBidders;\n    // taskId => array of subtask IDs\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Timeout: poster can refund if no claim/bid accepted after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // --- Admin ---\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        address old = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(old, _feeRecipient);\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Invalid owner\");\n        address old = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(old, _newOwner);\n    }\n\n    // --- Core Functions ---\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Bid on an open task with a proposed price and estimated time\n     * @param taskId Task to bid on\n     * @param price Proposed USDC price (can differ from bounty for negotiation)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price cannot exceed bounty\");\n        require(bids[taskId][msg.sender].bidder == address(0), \"Already bid\");\n\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        taskBidders[taskId].push(msg.sender);\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task, assigning the bidder as worker\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent supply chains)\n     * @dev The caller must be the worker of the parent task and funds come from their own balance\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique identifier for the subtask\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(bytes32 parentTaskId, bytes32 subtaskId, uint256 bountyAmount) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Submitted,\n            \"Parent must be claimed or submitted\"\n        );\n        require(msg.sender == parent.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remainder to worker\n        usdc.safeTransfer(task.worker, payout);\n\n        totalTasksCompleted++;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // --- View Functions ---\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    function getTaskBidders(bytes32 taskId) external view returns (address[] memory) {\n        return taskBidders[taskId];\n    }\n\n    function getSubtasks(bytes32 taskId) external view returns (bytes32[] memory) {\n        return subtasks[taskId];\n    }\n\n    function getSubtaskCount(bytes32 taskId) external view returns (uint256) {\n        return subtasks[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasks,\n        uint256 _totalCompleted,\n        uint256 _totalVolume,\n        uint256 _totalFees\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalVolumeUsdc, totalFeesCollected);\n    }\n\n    /**\n     * @notice Calculate fee for a given bounty amount\n     * @param bountyAmount The bounty to calculate fee for\n     */\n    function calculateFee(uint256 bountyAmount) external pure returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n}\n"}},{"tool_name":"Edit","tool_use_id":"toolu_01P9frPGXqSG4dwKxHsXhUm7","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","old_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers claim and deliver, \n *      poster approves to release funds. Supports disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 bounty);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n\n    constructor(address _usdc) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Release USDC to worker\n        usdc.safeTransfer(task.worker, task.bounty);\n\n        emit TaskApproved(taskId, task.worker, task.bounty);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        // In disputed state, funds remain in escrow\n        // A more advanced version would involve an arbitrator\n        // For now, disputed funds can be refunded by poster\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n        \n        bool canRefund = false;\n        \n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n        \n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        // Refund if submitted and dispute window expired without approval\n        // (Auto-approve protection: if poster never approves, worker can't get funds,\n        //  but poster can only refund during dispute. After dispute window,\n        //  the task auto-approves — handled off-chain or by worker calling approveTask)\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n}","new_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid on tasks,\n *      poster accepts bids, worker delivers, poster approves to release funds.\n *      Supports bidding, subtasks (agent supply chains), platform fees,\n *      disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant PLATFORM_FEE_BPS = 250;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    address public owner;\n\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalVolumeUsdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;\n    mapping(bytes32 => address[]) public taskBidders;\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    uint256 public claimTimeout = 7 days;\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // --- Admin ---\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        address old = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(old, _feeRecipient);\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Invalid owner\");\n        address old = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(old, _newOwner);\n    }\n\n    // --- Core Functions ---\n\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price cannot exceed bounty\");\n        require(bids[taskId][msg.sender].bidder == address(0), \"Already bid\");\n\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        taskBidders[taskId].push(msg.sender);\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    function createSubtask(bytes32 parentTaskId, bytes32 subtaskId, uint256 bountyAmount) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Submitted,\n            \"Parent must be claimed or submitted\"\n        );\n        require(msg.sender == parent.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount);\n    }\n\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        uint256 fee = (task.bounty * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        usdc.safeTransfer(task.worker, payout);\n        totalTasksCompleted++;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // --- View Functions ---\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    function getTaskBidders(bytes32 taskId) external view returns (address[] memory) {\n        return taskBidders[taskId];\n    }\n\n    function getSubtasks(bytes32 taskId) external view returns (bytes32[] memory) {\n        return subtasks[taskId];\n    }\n\n    function getSubtaskCount(bytes32 taskId) external view returns (uint256) {\n        return subtasks[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasks,\n        uint256 _totalCompleted,\n        uint256 _totalVolume,\n        uint256 _totalFees\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalVolumeUsdc, totalFeesCollected);\n    }\n\n    function calculateFee(uint256 bountyAmount) external pure returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n}","replace_all":false}},{"tool_name":"Write","tool_use_id":"toolu_01RdWipALa9ryx2TY5LN5y1g","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid on tasks,\n *      poster accepts bids, worker delivers, poster approves to release funds.\n *      Supports bidding, subtasks (agent supply chains), platform fees,\n *      disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public constant PLATFORM_FEE_BPS = 250;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    address public feeRecipient;\n    address public owner;\n\n    uint256 public totalFeesCollected;\n    uint256 public totalTasksCreated;\n    uint256 public totalTasksCompleted;\n    uint256 public totalVolumeUsdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;\n    mapping(bytes32 => address[]) public taskBidders;\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    uint256 public claimTimeout = 7 days;\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n        owner = msg.sender;\n    }\n\n    // --- Admin ---\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        address old = feeRecipient;\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(old, _feeRecipient);\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Invalid owner\");\n        address old = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(old, _newOwner);\n    }\n\n    // --- Core Functions ---\n\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Price cannot exceed bounty\");\n        require(bids[taskId][msg.sender].bidder == address(0), \"Already bid\");\n\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        });\n\n        taskBidders[taskId].push(msg.sender);\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    function createSubtask(bytes32 parentTaskId, bytes32 subtaskId, uint256 bountyAmount) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Submitted,\n            \"Parent must be claimed or submitted\"\n        );\n        require(msg.sender == parent.worker, \"Only parent worker can create subtask\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        totalTasksCreated++;\n        totalVolumeUsdc += bountyAmount;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount);\n    }\n\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        uint256 fee = (task.bounty * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        usdc.safeTransfer(task.worker, payout);\n        totalTasksCompleted++;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // --- View Functions ---\n\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    function getTaskBidders(bytes32 taskId) external view returns (address[] memory) {\n        return taskBidders[taskId];\n    }\n\n    function getSubtasks(bytes32 taskId) external view returns (bytes32[] memory) {\n        return subtasks[taskId];\n    }\n\n    function getSubtaskCount(bytes32 taskId) external view returns (uint256) {\n        return subtasks[taskId].length;\n    }\n\n    function getPlatformStats() external view returns (\n        uint256 _totalTasks,\n        uint256 _totalCompleted,\n        uint256 _totalVolume,\n        uint256 _totalFees\n    ) {\n        return (totalTasksCreated, totalTasksCompleted, totalVolumeUsdc, totalFeesCollected);\n    }\n\n    function calculateFee(uint256 bountyAmount) external pure returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n}\n"}}],"uuid":"48f9fd14-2cc7-41bf-9e7f-8a7b33e87398"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h