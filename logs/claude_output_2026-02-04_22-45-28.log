^D{"type":"result","subtype":"success","is_error":false,"duration_ms":297976,"duration_api_ms":308040,"num_turns":10,"result":"I need write permissions to proceed. Could you grant write access to the project directory? The file operations are being blocked. Once you approve, I'll be able to write the upgraded smart contract, set up Hardhat, create tests, and build out the full project.\n\nIn the meantime, let me outline what I'm building for Phase 1:\n\n**Smart Contract Upgrades (TaskEscrow.sol):**\n- Added `owner`, `feeRecipient` state variables\n- 2.5% platform fee (250 basis points) on `approveTask()` — fee goes to `feeRecipient`, worker gets 97.5%\n- `Bid` struct with bidder, price, estimatedTime, timestamp, accepted\n- `bidOnTask(taskId, price, estimatedTime)` — agents bid, can't bid twice, can't exceed bounty\n- `acceptBid(taskId, bidder)` — poster picks winner, refunds difference if bid < bounty\n- `createSubtask(parentTaskId, subtaskId, bountyAmount)` — agent-to-agent subcontracting\n- Platform stats tracking: `totalTasksCreated`, `totalFeesCollected`, `totalVolumeProcessed`\n- Admin functions: `setFeeBps`, `setFeeRecipient`, `transferOwnership`\n- Constructor now takes `_feeRecipient` as second parameter\n- All new events: TaskBid, BidAccepted, SubtaskCreated, FeeUpdated, etc.\n\nPlease grant write permissions so I can proceed with the implementation.","session_id":"a69d37f5-2c0b-4b2b-8022-0fa3632afc02","total_cost_usd":1.0731516,"usage":{"input_tokens":10,"cache_creation_input_tokens":34966,"cache_read_input_tokens":392918,"output_tokens":17470,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":34966,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":13039,"outputTokens":9710,"cacheReadInputTokens":849611,"cacheCreationInputTokens":59844,"webSearchRequests":0,"costUSD":0.22135510000000003,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":10,"outputTokens":17470,"cacheReadInputTokens":392918,"cacheCreationInputTokens":34966,"webSearchRequests":0,"costUSD":0.8517965,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Write","tool_use_id":"toolu_012TyroZkMRT32BCGLVHCHJe","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties. Workers bid on tasks, posters accept bids.\n *      Workers deliver, poster approves to release funds (minus platform fee).\n *      Supports agent-to-agent subcontracting via subtasks.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n    address public owner;\n    address public feeRecipient;\n\n    // Platform fee in basis points (250 = 2.5%)\n    uint256 public feeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // 10% max\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if top-level task\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    // taskId => array of bids\n    mapping(bytes32 => Bid[]) public taskBids;\n    // taskId => array of subtask IDs\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Platform stats\n    uint256 public totalTasksCreated;\n    uint256 public totalFeesCollected;\n    uint256 public totalVolumeProcessed;\n\n    // Timeout: poster can refund if no claim/bid acceptance after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event OwnershipTransferred(address oldOwner, address newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        owner = msg.sender;\n        feeRecipient = _feeRecipient;\n    }\n\n    // =========================================================================\n    //                           TASK LIFECYCLE\n    // =========================================================================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        uint256 fee = (task.bounty * feeBps) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Pay worker\n        usdc.safeTransfer(task.worker, payout);\n\n        // Collect platform fee\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        totalVolumeProcessed += task.bounty;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // =========================================================================\n    //                            BIDDING SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (smallest unit)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid cannot exceed bounty\");\n\n        // Check bidder hasn't already bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster picks the winning bidder)\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the winning bidder\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        // Assign worker and update status\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query bids for\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    /**\n     * @notice Get bid count for a task\n     * @param taskId Task to query\n     * @return Number of bids\n     */\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    // =========================================================================\n    //                         SUBTASK SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev The caller (worker of parent task) becomes the poster of the subtask.\n     *      The worker funds the subtask from their own USDC — not from the parent escrow.\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Open,\n            \"Parent task not active\"\n        );\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask poster to escrow\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Get subtask IDs for a parent task\n     * @param parentTaskId Parent task to query\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get subtask count for a parent task\n     * @param parentTaskId Parent task to query\n     * @return Number of subtasks\n     */\n    function getSubtaskCount(bytes32 parentTaskId) external view returns (uint256) {\n        return subtasks[parentTaskId].length;\n    }\n\n    // =========================================================================\n    //                           VIEW FUNCTIONS\n    // =========================================================================\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate the fee for a given bounty amount\n     * @param bountyAmount Bounty to calculate fee for\n     * @return fee The platform fee amount\n     * @return payout The amount the worker receives\n     */\n    function calculateFee(uint256 bountyAmount) external view returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * feeBps) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n\n    // =========================================================================\n    //                           ADMIN FUNCTIONS\n    // =========================================================================\n\n    /**\n     * @notice Update the platform fee (only owner)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFeeBps(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = feeBps;\n        feeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient address (only owner)\n     * @param newRecipient New fee recipient\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid address\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Transfer ownership (only owner)\n     * @param newOwner New owner address\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_014EXgAg429dvvG7VPRj8mqs","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties. Workers bid on tasks, posters accept bids.\n *      Workers deliver, poster approves to release funds (minus platform fee).\n *      Supports agent-to-agent subcontracting via subtasks.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n    address public owner;\n    address public feeRecipient;\n\n    // Platform fee in basis points (250 = 2.5%)\n    uint256 public feeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // 10% max\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if top-level task\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    // taskId => array of bids\n    mapping(bytes32 => Bid[]) public taskBids;\n    // taskId => array of subtask IDs\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Platform stats\n    uint256 public totalTasksCreated;\n    uint256 public totalFeesCollected;\n    uint256 public totalVolumeProcessed;\n\n    // Timeout: poster can refund if no claim/bid acceptance after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event OwnershipTransferred(address oldOwner, address newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        owner = msg.sender;\n        feeRecipient = _feeRecipient;\n    }\n\n    // =========================================================================\n    //                           TASK LIFECYCLE\n    // =========================================================================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        uint256 fee = (task.bounty * feeBps) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        // Pay worker\n        usdc.safeTransfer(task.worker, payout);\n\n        // Collect platform fee\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        totalVolumeProcessed += task.bounty;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // =========================================================================\n    //                            BIDDING SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (smallest unit)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid cannot exceed bounty\");\n\n        // Check bidder hasn't already bid\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster picks the winning bidder)\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the winning bidder\n     */\n    function acceptBid(bytes32 taskId, address bidder) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        // Assign worker and update status\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query bids for\n     * @return Array of bids\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    /**\n     * @notice Get bid count for a task\n     * @param taskId Task to query\n     * @return Number of bids\n     */\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    // =========================================================================\n    //                         SUBTASK SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev The caller becomes the poster of the subtask and funds it with their own USDC.\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Open,\n            \"Parent task not active\"\n        );\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Get subtask IDs for a parent task\n     * @param parentTaskId Parent task to query\n     * @return Array of subtask IDs\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get subtask count for a parent task\n     * @param parentTaskId Parent task to query\n     * @return Number of subtasks\n     */\n    function getSubtaskCount(bytes32 parentTaskId) external view returns (uint256) {\n        return subtasks[parentTaskId].length;\n    }\n\n    // =========================================================================\n    //                           VIEW FUNCTIONS\n    // =========================================================================\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate the fee for a given bounty amount\n     * @param bountyAmount Bounty to calculate fee for\n     * @return fee The platform fee amount\n     * @return payout The amount the worker receives\n     */\n    function calculateFee(uint256 bountyAmount) external view returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * feeBps) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n\n    // =========================================================================\n    //                           ADMIN FUNCTIONS\n    // =========================================================================\n\n    /**\n     * @notice Update the platform fee (only owner)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFeeBps(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = feeBps;\n        feeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient address (only owner)\n     * @param newRecipient New fee recipient\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid address\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Transfer ownership (only owner)\n     * @param newOwner New owner address\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}},{"tool_name":"Edit","tool_use_id":"toolu_014v4CANykSJ4KQ9EsS4RozT","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","old_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers claim and deliver, \n *      poster approves to release funds. Supports disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 bounty);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n\n    constructor(address _usdc) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Release USDC to worker\n        usdc.safeTransfer(task.worker, task.bounty);\n\n        emit TaskApproved(taskId, task.worker, task.bounty);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        // In disputed state, funds remain in escrow\n        // A more advanced version would involve an arbitrator\n        // For now, disputed funds can be refunded by poster\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n        \n        bool canRefund = false;\n        \n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n        \n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        // Refund if submitted and dispute window expired without approval\n        // (Auto-approve protection: if poster never approves, worker can't get funds,\n        //  but poster can only refund during dispute. After dispute window,\n        //  the task auto-approves — handled off-chain or by worker calling approveTask)\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n}","new_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties. Workers bid on tasks, posters accept bids.\n *      Workers deliver, poster approves to release funds (minus platform fee).\n *      Supports agent-to-agent subcontracting via subtasks.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n    address public owner;\n    address public feeRecipient;\n\n    // Platform fee in basis points (250 = 2.5%)\n    uint256 public feeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // 10% max\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;  // bytes32(0) if top-level task\n        uint256 bidCount;\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;\n        uint256 estimatedTime; // seconds\n        uint256 timestamp;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => Bid[]) public taskBids;\n    mapping(bytes32 => bytes32[]) public subtasks;\n\n    // Platform stats\n    uint256 public totalTasksCreated;\n    uint256 public totalFeesCollected;\n    uint256 public totalVolumeProcessed;\n\n    // Timeout: poster can refund if no claim/bid acceptance after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 payout, uint256 fee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed poster, uint256 bounty);\n    event FeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n    event OwnershipTransferred(address oldOwner, address newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _usdc, address _feeRecipient) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        owner = msg.sender;\n        feeRecipient = _feeRecipient;\n    }\n\n    // =========================================================================\n    //                           TASK LIFECYCLE\n    // =========================================================================\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0\n        });\n\n        totalTasksCreated++;\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        uint256 fee = (task.bounty * feeBps) / BPS_DENOMINATOR;\n        uint256 payout = task.bounty - fee;\n\n        usdc.safeTransfer(task.worker, payout);\n\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        totalVolumeProcessed += task.bounty;\n\n        emit TaskApproved(taskId, task.worker, payout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    // =========================================================================\n    //                            BIDDING SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (smallest unit)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0, \"Price must be > 0\");\n        require(price <= task.bounty, \"Bid cannot exceed bounty\");\n\n        Bid[] storage bids = taskBids[taskId];\n        for (uint256 i = 0; i < bids.length; i++) {\n            require(bids[i].bidder != msg.sender, \"Already bid on this task\");\n        }\n\n        bids.push(Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false\n        }));\n\n        task.bidCount++;\n        emit TaskBid(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster picks the winning bidder)\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the winning bidder\n     */\n    function acceptBid(bytes32 taskId, address bidder) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid[] storage bids = taskBids[taskId];\n        bool found = false;\n        uint256 acceptedPrice = 0;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder == bidder) {\n                bids[i].accepted = true;\n                acceptedPrice = bids[i].price;\n                found = true;\n                break;\n            }\n        }\n\n        require(found, \"Bidder not found\");\n\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price < bounty, refund difference to poster\n        if (acceptedPrice < task.bounty) {\n            uint256 refundAmount = task.bounty - acceptedPrice;\n            task.bounty = acceptedPrice;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, acceptedPrice);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     */\n    function getTaskBids(bytes32 taskId) external view returns (Bid[] memory) {\n        return taskBids[taskId];\n    }\n\n    /**\n     * @notice Get bid count for a task\n     */\n    function getBidCount(bytes32 taskId) external view returns (uint256) {\n        return taskBids[taskId].length;\n    }\n\n    // =========================================================================\n    //                         SUBTASK SYSTEM\n    // =========================================================================\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param parentTaskId The parent task this subtask belongs to\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC bounty for the subtask\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount\n    ) external nonReentrant {\n        Task storage parentTask = tasks[parentTaskId];\n        require(parentTask.poster != address(0), \"Parent task does not exist\");\n        require(\n            parentTask.status == Status.Claimed || parentTask.status == Status.Open,\n            \"Parent task not active\"\n        );\n        require(tasks[subtaskId].poster == address(0), \"Subtask ID already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n        totalTasksCreated++;\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Get subtask IDs for a parent task\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get subtask count for a parent task\n     */\n    function getSubtaskCount(bytes32 parentTaskId) external view returns (uint256) {\n        return subtasks[parentTaskId].length;\n    }\n\n    // =========================================================================\n    //                           VIEW FUNCTIONS\n    // =========================================================================\n\n    /**\n     * @notice Get task details\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Calculate the fee for a given bounty amount\n     */\n    function calculateFee(uint256 bountyAmount) external view returns (uint256 fee, uint256 payout) {\n        fee = (bountyAmount * feeBps) / BPS_DENOMINATOR;\n        payout = bountyAmount - fee;\n    }\n\n    // =========================================================================\n    //                           ADMIN FUNCTIONS\n    // =========================================================================\n\n    function setFeeBps(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = feeBps;\n        feeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid address\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}","replace_all":false}}],"uuid":"8f4b3791-969d-49bb-89be-ca46fb94317c"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h