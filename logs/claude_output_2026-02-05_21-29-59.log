^D{"type":"result","subtype":"success","is_error":false,"duration_ms":507235,"duration_api_ms":518529,"num_turns":19,"result":"I understand that write permissions need to be granted for me to proceed. The files I need to create/modify are:\n\n1. **contracts/TaskEscrow.sol** - Upgraded with fee, bidding, subtasks\n2. **hardhat.config.js** - Hardhat configuration\n3. **test/TaskEscrow.test.js** - Contract tests\n4. New CLI scripts for bidding\n5. Web UI components\n\nCould you please grant me permission to write files? Once granted, I'll be able to proceed quickly with the hackathon build. The deadline is Sunday Feb 8, so time is of the essence.\n\nIn the meantime, let me document exactly what changes I'm planning so you can review:\n\n## Smart Contract Changes (TaskEscrow.sol)\n\n**New Features:**\n- Platform fee: 2.5% (250 basis points) deducted on `approveTask()`\n- `feeRecipient` address receives fees\n- `bidOnTask(taskId, price, estimatedTime)` - agents bid on tasks\n- `acceptBid(taskId, bidder)` - poster selects winning bid\n- `withdrawBid(taskId)` - bidder can withdraw before acceptance\n- `createSubtask(taskId, bounty, acceptingBids, parentTaskId)` - agent-to-agent subcontracting\n- `cancelTask(taskId)` - poster can cancel open tasks\n- Admin functions: `setFee()`, `setFeeRecipient()`, `setClaimTimeout()`, `setDisputeWindow()`\n- Constructor now takes `_feeRecipient` parameter\n\n**New Events:**\n- `BidPlaced`, `BidAccepted`, `BidWithdrawn`\n- `SubtaskCreated`\n- `TaskCancelled`\n- `FeeUpdated`, `FeeRecipientUpdated`\n\nWould you like me to continue waiting for permissions, or is there another way you'd like me to proceed?","session_id":"4b9ddc52-c08e-44c2-82dd-bc854620a20c","total_cost_usd":2.0542055500000003,"usage":{"input_tokens":21,"cache_creation_input_tokens":53404,"cache_read_input_tokens":1215362,"output_tokens":37526,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":53404,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":21,"outputTokens":37526,"cacheReadInputTokens":1215362,"cacheCreationInputTokens":53404,"webSearchRequests":0,"costUSD":1.879711,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":22778,"outputTokens":8857,"cacheReadInputTokens":578478,"cacheCreationInputTokens":39667,"webSearchRequests":0,"costUSD":0.17449455000000003,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Bash","tool_use_id":"toolu_01SvsXunYvKafdDdckcpPmVs","tool_input":{"command":"tree -L 2 /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/ -I 'node_modules|dist'","description":"Show tree structure excluding node_modules and dist"}},{"tool_name":"Write","tool_use_id":"toolu_01JKP2c9jVqyEd6k64wW4KBn","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01WN7eMxa15seJC1LSpnHh8W","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01JaBtxJSkLhRRkjess3vxda","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01AwpLXF5ojXDQTE3X5FBMSi","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}},{"tool_name":"Edit","tool_use_id":"toolu_01SZ4ZnT8vHCUXFnTqvx4cHH","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","old_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers claim and deliver, \n *      poster approves to release funds. Supports disputes and refunds.\n */\ncontract TaskEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 bounty);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n\n    constructor(address _usdc) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount);\n    }\n\n    /**\n     * @notice Claim an open task as a worker\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Release USDC to worker\n        usdc.safeTransfer(task.worker, task.bounty);\n\n        emit TaskApproved(taskId, task.worker, task.bounty);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        // In disputed state, funds remain in escrow\n        // A more advanced version would involve an arbitrator\n        // For now, disputed funds can be refunded by poster\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n        \n        bool canRefund = false;\n        \n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n        \n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        // Refund if submitted and dispute window expired without approval\n        // (Auto-approve protection: if poster never approves, worker can't get funds,\n        //  but poster can only refund during dispute. After dispute window,\n        //  the task auto-approves  handled off-chain or by worker calling approveTask)\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n}","new_string":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}","replace_all":false}},{"tool_name":"Bash","tool_use_id":"toolu_015LoTsa1KRsSBSScu6CzTit","tool_input":{"command":"cd /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks && npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox","timeout":120000,"description":"Install Hardhat and toolbox"}},{"tool_name":"Bash","tool_use_id":"toolu_0192tPa3Dc3wWwashdFWNFjw","tool_input":{"command":"cd /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks && npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox","timeout":120000,"description":"Install Hardhat and toolbox for contract development"}},{"tool_name":"Bash","tool_use_id":"toolu_01BhQ9Ejd83TRGRYHyTAzsiC","tool_input":{"command":"cd /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks && npm install hardhat --save-dev","timeout":120000,"description":"Install Hardhat for contract development"}},{"tool_name":"Bash","tool_use_id":"toolu_013viNLpVe64x5BX18aN3cyL","tool_input":{"command":"npm install hardhat --save-dev --prefix /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks","timeout":120000,"description":"Install Hardhat for smart contract development"}},{"tool_name":"Bash","tool_use_id":"toolu_019RBCw9JJohode8wBPkq1By","tool_input":{"command":"npm install hardhat --save-dev --prefix /Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks","timeout":180000,"description":"Install Hardhat development dependency"}},{"tool_name":"Write","tool_use_id":"toolu_01E5NGGJLXf8Fo5QCpma9Qw5","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/hardhat.config.js","content":"require(\"@nomicfoundation/hardhat-toolbox\");\n\n// Load environment variables\nconst PRIVATE_KEY = process.env.PRIVATE_KEY || \"0x0000000000000000000000000000000000000000000000000000000000000001\";\nconst FEE_RECIPIENT = process.env.FEE_RECIPIENT || \"0x0000000000000000000000000000000000000001\";\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  solidity: {\n    version: \"0.8.20\",\n    settings: {\n      optimizer: {\n        enabled: true,\n        runs: 200\n      }\n    }\n  },\n  networks: {\n    hardhat: {\n      chainId: 31337,\n    },\n    amoy: {\n      url: \"https://rpc-amoy.polygon.technology\",\n      chainId: 80002,\n      accounts: [PRIVATE_KEY],\n    }\n  },\n  paths: {\n    sources: \"./contracts\",\n    tests: \"./test\",\n    cache: \"./cache\",\n    artifacts: \"./artifacts\"\n  },\n  etherscan: {\n    apiKey: {\n      polygonAmoy: process.env.POLYGONSCAN_API_KEY || \"\"\n    }\n  }\n};\n"}},{"tool_name":"Write","tool_use_id":"toolu_01Dv6R1tk82makxMUzvA19Wd","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for USDC-based agent task marketplace\n * @dev The Agent Economy Protocol - AI agents post tasks, bid on work, and get paid in USDC.\n *      Features: Platform fees, competitive bidding, agent-to-agent subcontracting.\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee: 2.5% = 250 basis points\n    uint256 public platformFeeBps = 250;\n    uint256 public constant MAX_FEE_BPS = 1000; // Max 10%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // Fee recipient address\n    address public feeRecipient;\n\n    // Total fees collected (for stats)\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;      // For subtasks: links to parent task\n        bool acceptingBids;        // True if task accepts competitive bids\n        uint256 bidCount;          // Number of bids received\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;             // Proposed price (can be <= bounty)\n        uint256 estimatedTime;     // Estimated delivery time in seconds\n        uint256 timestamp;\n        bool accepted;\n        bool withdrawn;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(address => Bid)) public bids;  // taskId => bidder => Bid\n    mapping(bytes32 => address[]) public taskBidders;         // taskId => list of bidders\n    mapping(bytes32 => bytes32[]) public subtasks;            // parentTaskId => child taskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(\n        bytes32 indexed taskId,\n        address indexed poster,\n        uint256 bounty,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    );\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(\n        bytes32 indexed taskId,\n        address indexed worker,\n        uint256 workerAmount,\n        uint256 platformFee\n    );\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster);\n\n    // Bidding events\n    event BidPlaced(\n        bytes32 indexed taskId,\n        address indexed bidder,\n        uint256 price,\n        uint256 estimatedTime\n    );\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event BidWithdrawn(bytes32 indexed taskId, address indexed bidder);\n\n    // Subtask events\n    event SubtaskCreated(\n        bytes32 indexed parentTaskId,\n        bytes32 indexed subtaskId,\n        address indexed creator,\n        uint256 bounty\n    );\n\n    // Admin events\n    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ Task Creation ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids Whether to accept competitive bids\n     */\n    function createTask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, bytes32(0));\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @param taskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids Whether to accept competitive bids\n     * @param parentTaskId The parent task this subtask belongs to\n     */\n    function createSubtask(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) external nonReentrant {\n        // Verify parent task exists and caller is the worker (subcontracting their work)\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(\n            msg.sender == parent.worker || msg.sender == parent.poster,\n            \"Only parent task worker or poster can create subtasks\"\n        );\n        require(\n            parent.status == Status.Claimed || parent.status == Status.Open,\n            \"Parent task must be open or claimed\"\n        );\n\n        _createTaskInternal(taskId, bountyAmount, acceptingBids, parentTaskId);\n\n        subtasks[parentTaskId].push(taskId);\n\n        emit SubtaskCreated(parentTaskId, taskId, msg.sender, bountyAmount);\n    }\n\n    function _createTaskInternal(\n        bytes32 taskId,\n        uint256 bountyAmount,\n        bool acceptingBids,\n        bytes32 parentTaskId\n    ) internal {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            acceptingBids: acceptingBids,\n            bidCount: 0\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids, parentTaskId);\n    }\n\n    // ============ Bidding System ============\n\n    /**\n     * @notice Place a bid on a task\n     * @param taskId Task to bid on\n     * @param price Proposed price (must be <= bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(\n        bytes32 taskId,\n        uint256 price,\n        uint256 estimatedTime\n    ) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(estimatedTime > 0, \"Invalid estimated time\");\n\n        // Check if bidder already has an active bid\n        Bid storage existingBid = bids[taskId][msg.sender];\n        require(\n            existingBid.bidder == address(0) || existingBid.withdrawn,\n            \"Already have an active bid\"\n        );\n\n        // Store bid\n        bids[taskId][msg.sender] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            timestamp: block.timestamp,\n            accepted: false,\n            withdrawn: false\n        });\n\n        // Track bidder if new\n        if (existingBid.bidder == address(0)) {\n            taskBidders[taskId].push(msg.sender);\n        }\n\n        task.bidCount++;\n\n        emit BidPlaced(taskId, msg.sender, price, estimatedTime);\n    }\n\n    /**\n     * @notice Accept a bid and assign the task to the bidder\n     * @param taskId Task to accept bid for\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Open, \"Task not open\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        Bid storage bid = bids[taskId][bidder];\n        require(bid.bidder != address(0), \"Bid does not exist\");\n        require(!bid.withdrawn, \"Bid was withdrawn\");\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    /**\n     * @notice Withdraw a bid (only if not yet accepted)\n     * @param taskId Task to withdraw bid from\n     */\n    function withdrawBid(bytes32 taskId) external {\n        Bid storage bid = bids[taskId][msg.sender];\n        require(bid.bidder != address(0), \"No bid found\");\n        require(!bid.accepted, \"Bid already accepted\");\n        require(!bid.withdrawn, \"Bid already withdrawn\");\n\n        bid.withdrawn = true;\n        tasks[taskId].bidCount--;\n\n        emit BidWithdrawn(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Get all bids for a task\n     * @param taskId Task to query\n     * @return bidders Array of bidder addresses\n     * @return bidPrices Array of bid prices\n     * @return bidTimes Array of estimated times\n     */\n    function getTaskBids(bytes32 taskId) external view returns (\n        address[] memory bidders,\n        uint256[] memory bidPrices,\n        uint256[] memory bidTimes\n    ) {\n        address[] storage allBidders = taskBidders[taskId];\n        uint256 activeBidCount = 0;\n\n        // Count active bids\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            if (!bids[taskId][allBidders[i]].withdrawn) {\n                activeBidCount++;\n            }\n        }\n\n        bidders = new address[](activeBidCount);\n        bidPrices = new uint256[](activeBidCount);\n        bidTimes = new uint256[](activeBidCount);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < allBidders.length; i++) {\n            Bid storage bid = bids[taskId][allBidders[i]];\n            if (!bid.withdrawn) {\n                bidders[j] = bid.bidder;\n                bidPrices[j] = bid.price;\n                bidTimes[j] = bid.estimatedTime;\n                j++;\n            }\n        }\n    }\n\n    // ============ Task Lifecycle ============\n\n    /**\n     * @notice Claim an open task as a worker (direct claim, no bidding)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task requires bidding\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee\n        uint256 fee = (task.bounty * platformFeeBps) / BPS_DENOMINATOR;\n        uint256 workerAmount = task.bounty - fee;\n\n        // Update total fees collected\n        totalFeesCollected += fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerAmount);\n\n        emit TaskApproved(taskId, task.worker, workerAmount, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task (before anyone claims)\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get subtasks of a parent task\n     * @param parentTaskId Parent task to query\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get a specific bid\n     * @param taskId Task to query\n     * @param bidder Bidder address\n     */\n    function getBid(bytes32 taskId, address bidder) external view returns (Bid memory) {\n        return bids[taskId][bidder];\n    }\n\n    /**\n     * @notice Calculate the worker amount after fees for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculateWorkerAmount(uint256 bounty) external view returns (uint256) {\n        uint256 fee = (bounty * platformFeeBps) / BPS_DENOMINATOR;\n        return bounty - fee;\n    }\n\n    /**\n     * @notice Calculate the platform fee for a given bounty\n     * @param bounty The bounty amount\n     */\n    function calculatePlatformFee(uint256 bounty) external view returns (uint256) {\n        return (bounty * platformFeeBps) / BPS_DENOMINATOR;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the platform fee (owner only)\n     * @param newFeeBps New fee in basis points\n     */\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit FeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update the fee recipient (owner only)\n     * @param newRecipient New fee recipient address\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    /**\n     * @notice Update claim timeout (owner only)\n     * @param newTimeout New timeout in seconds\n     */\n    function setClaimTimeout(uint256 newTimeout) external onlyOwner {\n        require(newTimeout >= 1 days, \"Timeout too short\");\n        claimTimeout = newTimeout;\n    }\n\n    /**\n     * @notice Update dispute window (owner only)\n     * @param newWindow New window in seconds\n     */\n    function setDisputeWindow(uint256 newWindow) external onlyOwner {\n        require(newWindow >= 1 days, \"Window too short\");\n        disputeWindow = newWindow;\n    }\n}\n"}}],"uuid":"227e1ef4-9c7f-40e4-b89b-48bc10b8fcd9"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h