^D{"type":"result","subtype":"success","is_error":false,"duration_ms":472319,"duration_api_ms":478443,"num_turns":33,"result":"I need file write and npm install permissions to proceed. Once those are granted, I can:\n\n1. Write the upgraded smart contract with bidding, platform fees, and subtasks\n2. Install Hardhat for testing\n3. Write comprehensive tests\n4. Deploy to Polygon Amoy\n5. Update CLI scripts\n6. Build the dark theme web UI\n\nPlease grant permissions for:\n- File writes to `/Users/timmethy/Developer/claw-marketplace/`\n- Running `npm install` commands\n\nOnce those are granted, I'll continue with the implementation.","session_id":"fd111f4c-447d-4861-ab0b-71a1fe6432bc","total_cost_usd":2.2662975000000007,"usage":{"input_tokens":26,"cache_creation_input_tokens":65131,"cache_read_input_tokens":1635310,"output_tokens":33705,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":65131,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":26,"outputTokens":33705,"cacheReadInputTokens":1635310,"cacheCreationInputTokens":65131,"webSearchRequests":0,"costUSD":2.0674787500000003,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":14609,"outputTokens":7547,"cacheReadInputTokens":779685,"cacheCreationInputTokens":54805,"webSearchRequests":0,"costUSD":0.19881875000000004,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[{"tool_name":"Bash","tool_use_id":"toolu_01PLfbL7virqDZR8ew2vBsPn","tool_input":{"command":"tree -L 3 -I 'node_modules|dist' /Users/timmethy/Developer/claw-marketplace 2>/dev/null || find /Users/timmethy/Developer/claw-marketplace -maxdepth 3 -not -path '*/node_modules/*' -not -path '*/\\.git/*' -type f | sort"}},{"tool_name":"Write","tool_use_id":"toolu_018dnBjcTEgrA68VKdqNpPkS","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01N93LQr3CMLX3MmyJLjaQZo","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01Xu9ZakhixWb7s7SUvC8H3G","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}},{"tool_name":"Write","tool_use_id":"toolu_01VTRq6fHUjNdo52eshxiw1t","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}},{"tool_name":"Bash","tool_use_id":"toolu_013wyZAUoAvPHiUNH1HsWc99","tool_input":{"command":"npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-chai-matchers chai @types/mocha 2>&1 | tail -20","timeout":120000,"description":"Install Hardhat and testing dependencies"}},{"tool_name":"Bash","tool_use_id":"toolu_01KrtXJdtmKCsz6ors2DzU1R","tool_input":{"command":"npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-chai-matchers chai @types/mocha","timeout":120000,"description":"Install Hardhat and testing dependencies"}},{"tool_name":"Bash","tool_use_id":"toolu_01PzbZq6CUffyCCjP1yZnVgV","tool_input":{"command":"npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-chai-matchers chai @types/mocha","timeout":120000,"description":"Install Hardhat and testing dependencies in the project"}},{"tool_name":"Bash","tool_use_id":"toolu_018Yw9MQfCbfr49gTvsrn3kH","tool_input":{"command":"npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox","timeout":180000,"description":"Install Hardhat framework for smart contract development"}},{"tool_name":"Write","tool_use_id":"toolu_01A7HGq6iaS4Q8bXk3iLZeuz","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}},{"tool_name":"Bash","tool_use_id":"toolu_01SXaBTJdQ2SsvbwUGpFt5re","tool_input":{"command":"npm install hardhat --save-dev","timeout":180000,"description":"Install Hardhat framework"}},{"tool_name":"Write","tool_use_id":"toolu_01XvVZWxNKncCnB2k9epVmPY","tool_input":{"file_path":"/Users/timmethy/Developer/claw-marketplace/skill/usdc-agent-tasks/contracts/TaskEscrow.sol","content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TaskEscrow\n * @notice Escrow contract for the Agent Economy Protocol — USDC-based agent task marketplace\n * @dev Agents post tasks with USDC bounties, workers bid and deliver,\n *      poster approves to release funds (minus platform fee). Supports agent-to-agent subcontracting.\n *\n * Key Features:\n * - Bidding system: Multiple agents can bid on tasks\n * - Platform fee: 2.5% on task completion\n * - Subtask support: Agents can subcontract work to other agents\n * - Full escrow protection with ReentrancyGuard and SafeERC20\n */\ncontract TaskEscrow is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable usdc;\n\n    // Platform fee configuration\n    uint256 public platformFeeBps = 250; // 2.5% = 250 basis points\n    address public feeRecipient;\n    uint256 public totalFeesCollected;\n\n    enum Status { Open, Claimed, Submitted, Approved, Disputed, Refunded, Cancelled }\n\n    struct Task {\n        address poster;\n        address worker;\n        uint256 bounty;\n        Status status;\n        bytes32 deliverableHash;\n        uint256 createdAt;\n        uint256 claimedAt;\n        uint256 submittedAt;\n        bytes32 parentTaskId;     // For subtasks: links to parent task\n        uint256 bidCount;         // Number of bids received\n        bool acceptingBids;       // Whether task is in bidding mode\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 price;            // Proposed price in USDC (can be less than bounty)\n        uint256 estimatedTime;    // Estimated delivery time in seconds\n        uint256 bidAt;\n        bool accepted;\n    }\n\n    mapping(bytes32 => Task) public tasks;\n    mapping(bytes32 => mapping(uint256 => Bid)) public taskBids; // taskId => bidIndex => Bid\n    mapping(bytes32 => mapping(address => uint256)) public bidderIndex; // taskId => bidder => bidIndex+1 (0 = no bid)\n    mapping(bytes32 => bytes32[]) public subtasks; // parentTaskId => childTaskIds\n\n    // Timeout: poster can refund if no claim after this period\n    uint256 public claimTimeout = 7 days;\n    // Dispute window: poster can dispute within this period after submission\n    uint256 public disputeWindow = 3 days;\n\n    // --- Events ---\n    event TaskCreated(bytes32 indexed taskId, address indexed poster, uint256 bounty, bool acceptingBids);\n    event TaskBid(bytes32 indexed taskId, address indexed bidder, uint256 price, uint256 estimatedTime, uint256 bidIndex);\n    event BidAccepted(bytes32 indexed taskId, address indexed bidder, uint256 price);\n    event TaskClaimed(bytes32 indexed taskId, address indexed worker);\n    event DeliverableSubmitted(bytes32 indexed taskId, bytes32 deliverableHash);\n    event TaskApproved(bytes32 indexed taskId, address indexed worker, uint256 workerPayout, uint256 platformFee);\n    event TaskDisputed(bytes32 indexed taskId);\n    event TaskRefunded(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event TaskCancelled(bytes32 indexed taskId, address indexed poster, uint256 bounty);\n    event SubtaskCreated(bytes32 indexed parentTaskId, bytes32 indexed subtaskId, address indexed creator, uint256 bounty);\n    event PlatformFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event FeeRecipientUpdated(address oldRecipient, address newRecipient);\n\n    constructor(address _usdc, address _feeRecipient) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        usdc = IERC20(_usdc);\n        feeRecipient = _feeRecipient;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @notice Update platform fee (only owner)\n     * @param newFeeBps New fee in basis points (max 1000 = 10%)\n     */\n    function setPlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n\n    /**\n     * @notice Update fee recipient address (only owner)\n     * @param newRecipient New address to receive fees\n     */\n    function setFeeRecipient(address newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"Invalid recipient\");\n        address oldRecipient = feeRecipient;\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(oldRecipient, newRecipient);\n    }\n\n    // ============ TASK CREATION ============\n\n    /**\n     * @notice Post a new task with USDC bounty (deposited into escrow)\n     * @param taskId Unique task identifier\n     * @param bountyAmount USDC amount (in smallest unit, 6 decimals)\n     * @param acceptingBids If true, task enters bidding mode; if false, first-come-first-served\n     */\n    function createTask(bytes32 taskId, uint256 bountyAmount, bool acceptingBids) external nonReentrant {\n        require(tasks[taskId].poster == address(0), \"Task already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from poster to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[taskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: bytes32(0),\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        emit TaskCreated(taskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    /**\n     * @notice Create a subtask linked to a parent task (agent-to-agent subcontracting)\n     * @dev Only the worker of the parent task can create subtasks\n     * @param parentTaskId The parent task ID\n     * @param subtaskId Unique subtask identifier\n     * @param bountyAmount USDC amount for the subtask\n     * @param acceptingBids If true, subtask enters bidding mode\n     */\n    function createSubtask(\n        bytes32 parentTaskId,\n        bytes32 subtaskId,\n        uint256 bountyAmount,\n        bool acceptingBids\n    ) external nonReentrant {\n        Task storage parent = tasks[parentTaskId];\n        require(parent.poster != address(0), \"Parent task does not exist\");\n        require(parent.status == Status.Claimed, \"Parent task must be claimed\");\n        require(msg.sender == parent.worker, \"Only parent task worker can create subtasks\");\n        require(tasks[subtaskId].poster == address(0), \"Subtask already exists\");\n        require(bountyAmount > 0, \"Bounty must be > 0\");\n\n        // Transfer USDC from subtask creator (parent task worker) to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), bountyAmount);\n\n        tasks[subtaskId] = Task({\n            poster: msg.sender,\n            worker: address(0),\n            bounty: bountyAmount,\n            status: Status.Open,\n            deliverableHash: bytes32(0),\n            createdAt: block.timestamp,\n            claimedAt: 0,\n            submittedAt: 0,\n            parentTaskId: parentTaskId,\n            bidCount: 0,\n            acceptingBids: acceptingBids\n        });\n\n        subtasks[parentTaskId].push(subtaskId);\n\n        emit SubtaskCreated(parentTaskId, subtaskId, msg.sender, bountyAmount);\n        emit TaskCreated(subtaskId, msg.sender, bountyAmount, acceptingBids);\n    }\n\n    // ============ BIDDING SYSTEM ============\n\n    /**\n     * @notice Place a bid on an open task\n     * @param taskId Task to bid on\n     * @param price Proposed price in USDC (can be less than or equal to bounty)\n     * @param estimatedTime Estimated delivery time in seconds\n     */\n    function bidOnTask(bytes32 taskId, uint256 price, uint256 estimatedTime) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not accepting bids\");\n        require(msg.sender != task.poster, \"Poster cannot bid on own task\");\n        require(price > 0 && price <= task.bounty, \"Invalid bid price\");\n        require(bidderIndex[taskId][msg.sender] == 0, \"Already bid on this task\");\n\n        uint256 bidIdx = task.bidCount;\n        task.bidCount++;\n\n        taskBids[taskId][bidIdx] = Bid({\n            bidder: msg.sender,\n            price: price,\n            estimatedTime: estimatedTime,\n            bidAt: block.timestamp,\n            accepted: false\n        });\n\n        bidderIndex[taskId][msg.sender] = bidIdx + 1; // Store index + 1 (0 means no bid)\n\n        emit TaskBid(taskId, msg.sender, price, estimatedTime, bidIdx);\n    }\n\n    /**\n     * @notice Accept a bid on a task (poster only)\n     * @param taskId Task ID\n     * @param bidder Address of the bidder to accept\n     */\n    function acceptBid(bytes32 taskId, address bidder) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(task.acceptingBids, \"Task not in bidding mode\");\n        require(msg.sender == task.poster, \"Only poster can accept bids\");\n\n        uint256 bidIdx = bidderIndex[taskId][bidder];\n        require(bidIdx > 0, \"Bidder has not bid on this task\");\n        bidIdx--; // Convert back to 0-indexed\n\n        Bid storage bid = taskBids[taskId][bidIdx];\n        require(!bid.accepted, \"Bid already accepted\");\n\n        bid.accepted = true;\n        task.worker = bidder;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        // If bid price is less than bounty, refund the difference to poster\n        if (bid.price < task.bounty) {\n            uint256 refundAmount = task.bounty - bid.price;\n            task.bounty = bid.price;\n            usdc.safeTransfer(task.poster, refundAmount);\n        }\n\n        emit BidAccepted(taskId, bidder, bid.price);\n        emit TaskClaimed(taskId, bidder);\n    }\n\n    // ============ TASK LIFECYCLE ============\n\n    /**\n     * @notice Claim an open task as a worker (first-come-first-served mode only)\n     * @param taskId Task to claim\n     */\n    function claimTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Task not open\");\n        require(!task.acceptingBids, \"Task is in bidding mode - use bidOnTask instead\");\n        require(msg.sender != task.poster, \"Poster cannot claim own task\");\n\n        task.worker = msg.sender;\n        task.status = Status.Claimed;\n        task.claimedAt = block.timestamp;\n\n        emit TaskClaimed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Submit a deliverable hash as proof of work\n     * @param taskId Task to submit for\n     * @param deliverableHash Hash of the deliverable (e.g., IPFS CID hash)\n     */\n    function submitDeliverable(bytes32 taskId, bytes32 deliverableHash) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Claimed, \"Task not claimed\");\n        require(msg.sender == task.worker, \"Only worker can submit\");\n        require(deliverableHash != bytes32(0), \"Invalid deliverable hash\");\n\n        task.deliverableHash = deliverableHash;\n        task.status = Status.Submitted;\n        task.submittedAt = block.timestamp;\n\n        emit DeliverableSubmitted(taskId, deliverableHash);\n    }\n\n    /**\n     * @notice Approve the deliverable and release USDC to worker (minus platform fee)\n     * @param taskId Task to approve\n     */\n    function approveTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can approve\");\n\n        task.status = Status.Approved;\n\n        // Calculate platform fee and worker payout\n        uint256 fee = (task.bounty * platformFeeBps) / 10000;\n        uint256 workerPayout = task.bounty - fee;\n\n        // Transfer fee to platform\n        if (fee > 0) {\n            usdc.safeTransfer(feeRecipient, fee);\n            totalFeesCollected += fee;\n        }\n\n        // Release remaining USDC to worker\n        usdc.safeTransfer(task.worker, workerPayout);\n\n        emit TaskApproved(taskId, task.worker, workerPayout, fee);\n    }\n\n    /**\n     * @notice Dispute a submitted deliverable (within dispute window)\n     * @param taskId Task to dispute\n     */\n    function disputeTask(bytes32 taskId) external {\n        Task storage task = tasks[taskId];\n        require(task.status == Status.Submitted, \"Task not submitted\");\n        require(msg.sender == task.poster, \"Only poster can dispute\");\n        require(\n            block.timestamp <= task.submittedAt + disputeWindow,\n            \"Dispute window expired\"\n        );\n\n        task.status = Status.Disputed;\n        emit TaskDisputed(taskId);\n    }\n\n    /**\n     * @notice Refund the poster (if no claim after timeout, or after dispute)\n     * @param taskId Task to refund\n     */\n    function refund(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(msg.sender == task.poster, \"Only poster can refund\");\n\n        bool canRefund = false;\n\n        // Refund if open and claim timeout expired\n        if (task.status == Status.Open && block.timestamp > task.createdAt + claimTimeout) {\n            canRefund = true;\n        }\n\n        // Refund if disputed\n        if (task.status == Status.Disputed) {\n            canRefund = true;\n        }\n\n        require(canRefund, \"Cannot refund at this time\");\n\n        task.status = Status.Refunded;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskRefunded(taskId, task.poster, task.bounty);\n    }\n\n    /**\n     * @notice Cancel an open task before anyone claims it\n     * @param taskId Task to cancel\n     */\n    function cancelTask(bytes32 taskId) external nonReentrant {\n        Task storage task = tasks[taskId];\n        require(task.poster != address(0), \"Task does not exist\");\n        require(task.status == Status.Open, \"Can only cancel open tasks\");\n        require(msg.sender == task.poster, \"Only poster can cancel\");\n\n        task.status = Status.Cancelled;\n        usdc.safeTransfer(task.poster, task.bounty);\n\n        emit TaskCancelled(taskId, task.poster, task.bounty);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @notice Get task details\n     * @param taskId Task to query\n     */\n    function getTask(bytes32 taskId) external view returns (Task memory) {\n        return tasks[taskId];\n    }\n\n    /**\n     * @notice Get a specific bid on a task\n     * @param taskId Task ID\n     * @param bidIndex Index of the bid\n     */\n    function getBid(bytes32 taskId, uint256 bidIndex) external view returns (Bid memory) {\n        return taskBids[taskId][bidIndex];\n    }\n\n    /**\n     * @notice Get all subtask IDs for a parent task\n     * @param parentTaskId Parent task ID\n     */\n    function getSubtasks(bytes32 parentTaskId) external view returns (bytes32[] memory) {\n        return subtasks[parentTaskId];\n    }\n\n    /**\n     * @notice Get the bid index for a specific bidder on a task\n     * @param taskId Task ID\n     * @param bidder Bidder address\n     * @return index The bid index (0 if no bid exists)\n     * @return hasBid Whether the bidder has placed a bid\n     */\n    function getBidderInfo(bytes32 taskId, address bidder) external view returns (uint256 index, bool hasBid) {\n        uint256 stored = bidderIndex[taskId][bidder];\n        if (stored == 0) {\n            return (0, false);\n        }\n        return (stored - 1, true);\n    }\n\n    /**\n     * @notice Calculate the fee and worker payout for a given bounty\n     * @param bounty The bounty amount\n     * @return fee The platform fee\n     * @return workerPayout The amount the worker receives\n     */\n    function calculatePayout(uint256 bounty) external view returns (uint256 fee, uint256 workerPayout) {\n        fee = (bounty * platformFeeBps) / 10000;\n        workerPayout = bounty - fee;\n    }\n\n    /**\n     * @notice Get platform statistics\n     * @return feeBps Current fee in basis points\n     * @return recipient Fee recipient address\n     * @return totalFees Total fees collected\n     */\n    function getPlatformStats() external view returns (uint256 feeBps, address recipient, uint256 totalFees) {\n        return (platformFeeBps, feeRecipient, totalFeesCollected);\n    }\n}\n"}}],"uuid":"f7807574-7e57-4826-be0d-a1dfdbf3c44b"}
[<u[?1004l[?2004l[?25h]9;4;0;[?25h